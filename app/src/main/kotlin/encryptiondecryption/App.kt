/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package encryptiondecryption

import java.io.*
import kotlin.math.abs
const val OFFSET = 1
fun main(args: Array<String>) {
    //default values:
    val listAlgo = listOf("shift", "unicode")
    var alg = "shift"
    val listMode = listOf("enc", "dec")
    var mode = "enc"
    var data: String? = null
    var key = 0
    var outfile: String? = null
    var infile: String? = null
    //scan the args:
    for (i in args.indices) {
        if (args[i] == "-alg") {
            var givenAlgo: String = alg
            try{
                givenAlgo = args[i+1]

                if(givenAlgo !in listAlgo){
                    println("Error : Enter enc for encrypt and dec for decrypt.")
                    return Unit
                }
                else{
                    alg = givenAlgo
                }

            }catch (e:Exception){
                println("Error : Default mode = enc is used.")
                return Unit
            }

        }
        if (args[i] == "-mode") {
            var givenMode: String? = null
            try {
                givenMode = args[i+1]
                if(givenMode !in listMode)
                {
                    println("Error : Enter enc for encrypt and dec for decrypt.")
                    return Unit
                }
                else{
                    mode = givenMode
                }
            }
            catch (e:Exception) {
                println("Error : Default mode = enc is used.")
                return Unit
            }
        }
        if (args[i] == "-key") {
            try {
                key = args[i+1].toInt()
            }
            catch (e:Exception) {
                println("Error : Default mode = enc is used.")
                return Unit
            }
        }
        if (args[i] == "-data") {
            try {
                data = args[i+1]
            }
            catch (e:Exception) {
                println("Error : Default data = empty is used.")
                return Unit
            }
        }
        if (args[i] == "-out"){
            try{
                outfile = args[i+1]
            }
            catch (e:Exception){
                println("Error : Provide output file.")
                return Unit
            }
        }

        if(args[i] == "-in"){
            try{
                infile = args[i+1]
            }
            catch (e:Exception){
                println("Error : Provide input file.")
            }
        }

    }
    //check rules:
    val useInfile: Boolean =
        if (data.isNullOrEmpty() && infile.isNullOrEmpty()) {
            data = ""
            false
        }
        else if (data.isNullOrEmpty() && !infile.isNullOrEmpty()) {
            true
        }

        else if (!data.isNullOrEmpty() && !infile.isNullOrEmpty()) {
            false
        }
        else {
            false
        }

    val commonData =
        if(useInfile){
            File(infile!!).bufferedReader().use{
                it.readText()
            }
        }
        else{
            data!!
        }
    val result = when(mode) {
        "enc" -> if(alg == "shift") {
            encryptWithKeyShift(commonData,key)
        } else encryptWithKeyUnicode(commonData,key)
        "dec" -> if(alg == "shift") {
            decryptWithKeyShift(commonData,key)
        }else decryptWithKeyUnicode(commonData,key)
        else -> {""}
    }

    if(outfile.isNullOrEmpty()){
        println(result)
    }
    else{
        File(outfile).writeText(result)
    }


}


